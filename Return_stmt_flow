RETURN STMT ::

Excellent question â€” this is the exact moment recursion really â€œclicksâ€ ğŸ‘
Letâ€™s be very precise and concrete.

Short answer (intuition first)

If you write plain:

forward(idx + 1)


instead of:

return forward(idx + 1)


then:

âœ… the recursive calls still run
âŒ but the result is thrown away
âŒ and the function eventually returns None

Thatâ€™s why you earlier saw â€œnull / None returnâ€.

What Python actually does (step-by-step)
Case 1ï¸âƒ£ â€” with return
return forward(idx + 1)


Means:

Call forward(idx + 1)

Wait for it to finish

Take its return value

Immediately return that value to the caller

So the value flows up the call stack.

Case 2ï¸âƒ£ â€” without return
forward(idx + 1)
# function ends here


Means:

Call forward(idx + 1)

Ignore whatever it returns

Reach the end of the function

Python implicitly does:

return None

Call-stack demonstration (simplified)
Code:
def f():
    g()

def g():
    return 6

Execution:
g() returns 6
f() ignores it
f() reaches end â†’ returns None


So:

print(f())   # None

Now relate this to your code
Wrong version:
arr.pop(idx)
forward(idx + 1)   # âŒ value discarded


Eventually:

Base case returns 6

Nobody returns it upward

Top call returns None

Correct version:
arr.pop(idx)
return forward(idx + 1)   # âœ… propagate result


Now:

Base case returns 6

Every caller returns that same 6

Final result is 6

Visual: value flow
âŒ Without return
base returns 6
â†‘ ignored
â†‘ ignored
â†‘ ignored
â†’ None

âœ… With return
base returns 6
â†‘ 6
â†‘ 6
â†‘ 6
â†’ 6

Golden rule (memorize this)

ğŸ”‘ Every recursive path must either

return a value directly, or

return the value of another recursive call

If you break the chain even once â†’ None.

If you want, next I can:

Show this bug using a tiny 3-element example

Explain how Python inserts return None

Show how languages like C++ behave differently

Just tell me.
